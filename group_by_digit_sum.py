def n_customers_per_group(n_customers):
    '''
    Функция подсчитывает число покупателей, попадающих в каждую группу,
    где номер группы равен сумме всех цифр ID клиента.
    ID клиента состоит из 5-7 цифр, нумерация сквозная и начинается с 0.
    
    Принимает количество клиентов, выдает словарь - число клиентов в группах.
    
    При итерации по ID клиентов группы заполняются поочередно, при этом 
    внутри каждого десятка клиентов прибавляется по единице к ряду из 10 групп
    т.е. вектор [1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    внутри каждой сотни ID - к ряду из 19 групп прибавляются числа, являющиеся
    ответом этой функции на n_customers = 99:
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1] и т.д.
    можно применить рекурсию, но при известном числе разрядов ID (до 7)
    цикл быстрее и понятнее.
    В отдельные функции выделены процедуры "сложения со сдвигом" и
    "умножения со сдвигом" списков.
    '''
    result_lst = []   
    # список для накопления числа людей в группах, индекс = номер группы
    block = [1]        
    # block - единица суммирования, усложняющаяся с каждым разрядом числа
    
    while n_customers:
        # цикл скользит по разрядам n_customers от меньших, пока не закончатся
        
        ones = n_customers % 10  # число единиц суммирования на данной итерации
        result_lst = shift_add(shift_multiply(block, ones), result_lst, ones)
        # сложение со сдвигом двух списков, сдвиг = значению текущего разряда
        # первый список состоит из повторенных со сдвигом единиц суммирования
        # число повторов = значению текущего разряда
        
        block = shift_multiply(block, 10)
        # усложнение единицы суммирования для следующей итерации
        n_customers //= 10       # отбрасывание младшего разряда
    return dict(pair for pair in enumerate(result_lst))
    # преобразует список в словарь, что нагляднее отображает подсчет клиентов в группах



def n_customers_per_group_from_start(n_customers, n_first_id):
    '''
    Функция подсчитывает число покупателей, попадающих в каждую группу,
    где номер группы равен сумме всех цифр ID клиента.
    ID клиента состоит из 5-7 цифр, нумерация сквозная, с произвольного числа.
    
    Принимает количество клиентов и первый ID в последовательности,
    выдает словарь числа клиентов в группах (ключ = номер группы)
    
    Функция использует описанную выше функцию, выдает результат как
    разницу двух списков: [от 0 до конца] и [от 0 до начала].
    '''
    from_zero_dct = n_customers_per_group(n_customers + n_first_id)
    from_zero_to_start_dct = n_customers_per_group(n_first_id)
    for i in from_zero_dct:
        from_zero_dct[i] -= from_zero_to_start_dct.pop(i, 0)
    return dict(pair for pair in from_zero_dct.items() if pair[1])


def shift_add(lst_1, lst_2, shift=2):
    '''
    Сложение со сдвигом: принимает 2 списка целых чисел и ненулевой сдвиг.
    Ко всем числам первого списка, начиная с позиции сдвига, прибавляет по одному числу
    из второго списка (с индексом большим на сзачение сдвига), 
    когда первый список заканчивается, прибавляет к нулям, например:
    [1, 2, 3, 4, 5] + [1, 1, 1, 1, 1] со сдвигом 3 = [1, 2, 3, 5, 6, 1, 1, 1], а
    [1, 10, 100, 1000] + [2, 20, 200, 2000] со сдвигом 1 = [1, 12, 120, 1200, 2000]
    '''
    len_1, len_2 = len(lst_1), len(lst_2) + shift
    len_common = max(len_1, len_2)
    zeroes_1 = len_common - len_1     # вычисление, сколько добавить нулей к спискам
    zeroes_2 = len_common - len_2
    zip_of_lists = zip(lst_1 + [0] * (zeroes_1), [0] * (shift) + lst_2 + [0] * (zeroes_2))
    return [sum(values) for values in zip_of_lists]


def shift_multiply(lst, repeat=1):
    '''
    Умножение со сдвигом: принимает список целых чисел и ненулевое число повторов.
    Список прибавляется сам к себе со сдвигом 1 указанное число раз, например:
    [1, 2, 3, 4, 5] * 3 = [1, 2, 3, 3, 3, 2, 1], а
    [1, 10, 100, 1000] * 5 = [1, 11, 111, 1111, 1111, 1110, 1100, 1000]
    '''    
    ext_lst = [0] * (repeat - 1) + lst + [0] * repeat
    return [sum(ext_lst[i + j] for j in range(repeat)) for i in range(repeat + len(lst) - 1)]


def check_positive(num):
    '''
    Контроль ввода целого неотрицательного числа; перевод в формат int
    '''
    try:
        num = int(num)
        if num >= 0:
            return num
        else:
            return check_positive(input(f'Ошибка. Введите число >= 0 вместо "{num}": '))
    except TypeError and ValueError:
        return check_positive(input(f'Ошибка. Введите целое число вместо "{num}": '))


if __name__ == "__main__":

    print('Демонстрация работы первой функции.') 
    n_customers = check_positive(input('Введите количество клиентов: '))
    print('Число покупателей, попадающих в каждую группу:') 
    print(n_customers_per_group(n_customers), '\n')
    
    print('Демонстрация работы второй функции.') 
    n_customers = check_positive(input('Введите количество клиентов: '))
    n_first_id = check_positive(input('Введите первый ID в последовательности: '))
    print('Число покупателей, попадающих в каждую группу:')
    second_dict = n_customers_per_group_from_start(n_customers, n_first_id)
    print(second_dict)
    
    if input('Хотите визуализацию последнего распределения? (Y / N) ').lower() == 'y':
        
        
        import matplotlib.pyplot as plt
        
        
        second_dict = n_customers_per_group_from_start(n_customers, n_first_id)
        plt.bar(list(second_dict.keys()), second_dict.values(), color='b')
        plt.show()

# Начиная с 30 клиентов распределение терпимое, начиная с 500 - красивое
        
